#!/usr/bin/env python
"""This small utility calculates distance between two conformations. 
It first attempts to rotate one of them to get closer to another,
in order to compensate for rotation of a globule as a whole. 
"""
import sys 
import numpy
import joblib
from numpy import sqrt
import scipy.optimize
np = numpy
from numpy import sin,cos

def rotation(theta):
   "calculates rotation matrix"
   tx,ty,tz = theta

   Rx = np.array([[1,0,0], [0, cos(tx), -sin(tx)], [0, sin(tx), cos(tx)]])
   Ry = np.array([[cos(ty), 0, -sin(ty)], [0, 1, 0], [sin(ty), 0, cos(ty)]])
   Rz = np.array([[cos(tz), -sin(tz), 0], [sin(tz), cos(tz), 0], [0,0,1]])

   return np.dot(Rx, np.dot(Ry, Rz))

def distN(a,b,N=40000):
    "Distance between subset of conformation of length N" 
    num = len(a) / N + 1
    newa = a[::num]
    newb = b[::num]
    return numpy.sqrt(numpy.mean((newa - newb)**2) * 3)


def load(filename):
    return joblib.load(filename)["data"]

try:data = load(sys.argv[1])
except:data = load("block%s.dat" % sys.argv[1])
N = len(data)
data = numpy.array(data)
dataa = data - numpy.sum(data,0)/float(len(data))

try:data = load(sys.argv[2])
except:data = load("block%s.dat" % sys.argv[2])

N = len(data)
data = numpy.array(data)
datab = data - numpy.sum(data,0)/float(len(data))

def distance(rotate):
    return distN(dataa,numpy.dot(datab,rotation(rotate)))

optimal =  scipy.optimize.fmin(distance,(1,1,1))

r = numpy.arange(len(dataa))
numpy.random.shuffle(r)
print "shuffled distance = ", distN(dataa, dataa[r])
print "original distance =", distN(dataa,datab)
print "optimized distance= ", distance(optimal)


